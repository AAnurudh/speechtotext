import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/resumablejs/resumable.js
var require_resumable = __commonJS({
  "node_modules/resumablejs/resumable.js"(exports, module) {
    (function() {
      "use strict";
      var Resumable = function(opts) {
        if (!(this instanceof Resumable)) {
          return new Resumable(opts);
        }
        this.version = 1;
        this.support = typeof File !== "undefined" && typeof Blob !== "undefined" && typeof FileList !== "undefined" && (!!Blob.prototype.webkitSlice || !!Blob.prototype.mozSlice || !!Blob.prototype.slice || false);
        if (!this.support) return false;
        var $ = this;
        $.files = [];
        $.defaults = {
          chunkSize: 1 * 1024 * 1024,
          forceChunkSize: false,
          simultaneousUploads: 3,
          fileParameterName: "file",
          chunkNumberParameterName: "resumableChunkNumber",
          chunkSizeParameterName: "resumableChunkSize",
          currentChunkSizeParameterName: "resumableCurrentChunkSize",
          totalSizeParameterName: "resumableTotalSize",
          typeParameterName: "resumableType",
          identifierParameterName: "resumableIdentifier",
          fileNameParameterName: "resumableFilename",
          relativePathParameterName: "resumableRelativePath",
          totalChunksParameterName: "resumableTotalChunks",
          throttleProgressCallbacks: 0.5,
          query: {},
          headers: {},
          preprocess: null,
          method: "multipart",
          uploadMethod: "POST",
          testMethod: "GET",
          prioritizeFirstAndLastChunk: false,
          target: "/",
          testTarget: null,
          parameterNamespace: "",
          testChunks: true,
          generateUniqueIdentifier: null,
          getTarget: null,
          maxChunkRetries: 100,
          chunkRetryInterval: void 0,
          permanentErrors: [400, 404, 415, 500, 501],
          maxFiles: void 0,
          withCredentials: false,
          xhrTimeout: 0,
          clearInput: true,
          chunkFormat: "blob",
          setChunkTypeFromFile: false,
          maxFilesErrorCallback: function(files, errorCount) {
            var maxFiles = $.getOpt("maxFiles");
            alert("Please upload no more than " + maxFiles + " file" + (maxFiles === 1 ? "" : "s") + " at a time.");
          },
          minFileSize: 1,
          minFileSizeErrorCallback: function(file, errorCount) {
            alert(file.fileName || file.name + " is too small, please upload files larger than " + $h.formatSize($.getOpt("minFileSize")) + ".");
          },
          maxFileSize: void 0,
          maxFileSizeErrorCallback: function(file, errorCount) {
            alert(file.fileName || file.name + " is too large, please upload files less than " + $h.formatSize($.getOpt("maxFileSize")) + ".");
          },
          fileType: [],
          fileTypeErrorCallback: function(file, errorCount) {
            alert(file.fileName || file.name + " has type not allowed, please upload files of type " + $.getOpt("fileType") + ".");
          }
        };
        $.opts = opts || {};
        $.getOpt = function(o) {
          var $opt = this;
          if (o instanceof Array) {
            var options = {};
            $h.each(o, function(option) {
              options[option] = $opt.getOpt(option);
            });
            return options;
          }
          if ($opt instanceof ResumableChunk) {
            if (typeof $opt.opts[o] !== "undefined") {
              return $opt.opts[o];
            } else {
              $opt = $opt.fileObj;
            }
          }
          if ($opt instanceof ResumableFile) {
            if (typeof $opt.opts[o] !== "undefined") {
              return $opt.opts[o];
            } else {
              $opt = $opt.resumableObj;
            }
          }
          if ($opt instanceof Resumable) {
            if (typeof $opt.opts[o] !== "undefined") {
              return $opt.opts[o];
            } else {
              return $opt.defaults[o];
            }
          }
        };
        $.events = [];
        $.on = function(event, callback) {
          $.events.push(event.toLowerCase(), callback);
        };
        $.fire = function() {
          var args = [];
          for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
          var event = args[0].toLowerCase();
          for (var i = 0; i <= $.events.length; i += 2) {
            if ($.events[i] == event) $.events[i + 1].apply($, args.slice(1));
            if ($.events[i] == "catchall") $.events[i + 1].apply(null, args);
          }
          if (event == "fileerror") $.fire("error", args[2], args[1]);
          if (event == "fileprogress") $.fire("progress");
        };
        var $h = {
          stopEvent: function(e) {
            e.stopPropagation();
            e.preventDefault();
          },
          each: function(o, callback) {
            if (typeof o.length !== "undefined") {
              for (var i = 0; i < o.length; i++) {
                if (callback(o[i]) === false) return;
              }
            } else {
              for (i in o) {
                if (callback(i, o[i]) === false) return;
              }
            }
          },
          generateUniqueIdentifier: function(file, event) {
            var custom = $.getOpt("generateUniqueIdentifier");
            if (typeof custom === "function") {
              return custom(file, event);
            }
            var relativePath = file.webkitRelativePath || file.fileName || file.name;
            var size = file.size;
            return size + "-" + relativePath.replace(/[^0-9a-zA-Z_-]/img, "");
          },
          contains: function(array, test) {
            var result = false;
            $h.each(array, function(value) {
              if (value == test) {
                result = true;
                return false;
              }
              return true;
            });
            return result;
          },
          formatSize: function(size) {
            if (size < 1024) {
              return size + " bytes";
            } else if (size < 1024 * 1024) {
              return (size / 1024).toFixed(0) + " KB";
            } else if (size < 1024 * 1024 * 1024) {
              return (size / 1024 / 1024).toFixed(1) + " MB";
            } else {
              return (size / 1024 / 1024 / 1024).toFixed(1) + " GB";
            }
          },
          getTarget: function(request, params) {
            var target = $.getOpt("target");
            if (request === "test" && $.getOpt("testTarget")) {
              target = $.getOpt("testTarget") === "/" ? $.getOpt("target") : $.getOpt("testTarget");
            }
            if (typeof target === "function") {
              return target(params);
            }
            var separator = target.indexOf("?") < 0 ? "?" : "&";
            var joinedParams = params.join("&");
            return target + separator + joinedParams;
          }
        };
        var onDrop = function(event) {
          $h.stopEvent(event);
          if (event.dataTransfer && event.dataTransfer.items) {
            loadFiles(event.dataTransfer.items, event);
          } else if (event.dataTransfer && event.dataTransfer.files) {
            loadFiles(event.dataTransfer.files, event);
          }
        };
        var preventDefault = function(e) {
          e.preventDefault();
        };
        function processItem(item, path, items, cb) {
          var entry;
          if (item.isFile) {
            return item.file(function(file) {
              file.relativePath = path + file.name;
              items.push(file);
              cb();
            });
          } else if (item.isDirectory) {
            entry = item;
          } else if (item instanceof File) {
            items.push(item);
          }
          if ("function" === typeof item.webkitGetAsEntry) {
            entry = item.webkitGetAsEntry();
          }
          if (entry && entry.isDirectory) {
            return processDirectory(entry, path + entry.name + "/", items, cb);
          }
          if ("function" === typeof item.getAsFile) {
            item = item.getAsFile();
            if (item instanceof File) {
              item.relativePath = path + item.name;
              items.push(item);
            }
          }
          cb();
        }
        function processCallbacks(items, cb) {
          if (!items || items.length === 0) {
            return cb();
          }
          items[0](function() {
            processCallbacks(items.slice(1), cb);
          });
        }
        function processDirectory(directory, path, items, cb) {
          var dirReader = directory.createReader();
          dirReader.readEntries(function(entries) {
            if (!entries.length) {
              return cb();
            }
            processCallbacks(
              entries.map(function(entry) {
                return processItem.bind(null, entry, path, items);
              }),
              cb
            );
          });
        }
        function loadFiles(items, event) {
          if (!items.length) {
            return;
          }
          $.fire("beforeAdd");
          var files = [];
          processCallbacks(
            Array.prototype.map.call(items, function(item) {
              return processItem.bind(null, item, "", files);
            }),
            function() {
              if (files.length) {
                appendFilesFromFileList(files, event);
              }
            }
          );
        }
        ;
        var appendFilesFromFileList = function(fileList, event) {
          var errorCount = 0;
          var o = $.getOpt(["maxFiles", "minFileSize", "maxFileSize", "maxFilesErrorCallback", "minFileSizeErrorCallback", "maxFileSizeErrorCallback", "fileType", "fileTypeErrorCallback"]);
          if (typeof o.maxFiles !== "undefined" && o.maxFiles < fileList.length + $.files.length) {
            if (o.maxFiles === 1 && $.files.length === 1 && fileList.length === 1) {
              $.removeFile($.files[0]);
            } else {
              o.maxFilesErrorCallback(fileList, errorCount++);
              return false;
            }
          }
          var files = [], filesSkipped = [], remaining = fileList.length;
          var decreaseReamining = function() {
            if (!--remaining) {
              if (!files.length && !filesSkipped.length) {
                return;
              }
              window.setTimeout(function() {
                $.fire("filesAdded", files, filesSkipped);
              }, 0);
            }
          };
          $h.each(fileList, function(file) {
            var fileName = file.name;
            if (o.fileType.length > 0) {
              var fileTypeFound = false;
              for (var index in o.fileType) {
                var extension = "." + o.fileType[index];
                if (fileName.toLowerCase().indexOf(extension.toLowerCase(), fileName.length - extension.length) !== -1) {
                  fileTypeFound = true;
                  break;
                }
              }
              if (!fileTypeFound) {
                o.fileTypeErrorCallback(file, errorCount++);
                return false;
              }
            }
            if (typeof o.minFileSize !== "undefined" && file.size < o.minFileSize) {
              o.minFileSizeErrorCallback(file, errorCount++);
              return false;
            }
            if (typeof o.maxFileSize !== "undefined" && file.size > o.maxFileSize) {
              o.maxFileSizeErrorCallback(file, errorCount++);
              return false;
            }
            function addFile(uniqueIdentifier2) {
              if (!$.getFromUniqueIdentifier(uniqueIdentifier2)) {
                (function() {
                  file.uniqueIdentifier = uniqueIdentifier2;
                  var f = new ResumableFile($, file, uniqueIdentifier2);
                  $.files.push(f);
                  files.push(f);
                  f.container = typeof event != "undefined" ? event.srcElement : null;
                  window.setTimeout(function() {
                    $.fire("fileAdded", f, event);
                  }, 0);
                })();
              } else {
                filesSkipped.push(file);
              }
              ;
              decreaseReamining();
            }
            var uniqueIdentifier = $h.generateUniqueIdentifier(file, event);
            if (uniqueIdentifier && typeof uniqueIdentifier.then === "function") {
              uniqueIdentifier.then(
                function(uniqueIdentifier2) {
                  addFile(uniqueIdentifier2);
                },
                function() {
                  decreaseReamining();
                }
              );
            } else {
              addFile(uniqueIdentifier);
            }
          });
        };
        function ResumableFile(resumableObj, file, uniqueIdentifier) {
          var $2 = this;
          $2.opts = {};
          $2.getOpt = resumableObj.getOpt;
          $2._prevProgress = 0;
          $2.resumableObj = resumableObj;
          $2.file = file;
          $2.fileName = file.fileName || file.name;
          $2.size = file.size;
          $2.relativePath = file.relativePath || file.webkitRelativePath || $2.fileName;
          $2.uniqueIdentifier = uniqueIdentifier;
          $2._pause = false;
          $2.container = "";
          var _error = uniqueIdentifier !== void 0;
          var chunkEvent = function(event, message) {
            switch (event) {
              case "progress":
                $2.resumableObj.fire("fileProgress", $2, message);
                break;
              case "error":
                $2.abort();
                _error = true;
                $2.chunks = [];
                $2.resumableObj.fire("fileError", $2, message);
                break;
              case "success":
                if (_error) return;
                $2.resumableObj.fire("fileProgress", $2);
                if ($2.isComplete()) {
                  $2.resumableObj.fire("fileSuccess", $2, message);
                }
                break;
              case "retry":
                $2.resumableObj.fire("fileRetry", $2);
                break;
            }
          };
          $2.chunks = [];
          $2.abort = function() {
            var abortCount = 0;
            $h.each($2.chunks, function(c) {
              if (c.status() == "uploading") {
                c.abort();
                abortCount++;
              }
            });
            if (abortCount > 0) $2.resumableObj.fire("fileProgress", $2);
          };
          $2.cancel = function() {
            var _chunks = $2.chunks;
            $2.chunks = [];
            $h.each(_chunks, function(c) {
              if (c.status() == "uploading") {
                c.abort();
                $2.resumableObj.uploadNextChunk();
              }
            });
            $2.resumableObj.removeFile($2);
            $2.resumableObj.fire("fileProgress", $2);
          };
          $2.retry = function() {
            $2.bootstrap();
            var firedRetry = false;
            $2.resumableObj.on("chunkingComplete", function() {
              if (!firedRetry) $2.resumableObj.upload();
              firedRetry = true;
            });
          };
          $2.bootstrap = function() {
            $2.abort();
            _error = false;
            $2.chunks = [];
            $2._prevProgress = 0;
            var round = $2.getOpt("forceChunkSize") ? Math.ceil : Math.floor;
            var maxOffset = Math.max(round($2.file.size / $2.getOpt("chunkSize")), 1);
            for (var offset = 0; offset < maxOffset; offset++) {
              (function(offset2) {
                window.setTimeout(function() {
                  $2.chunks.push(new ResumableChunk($2.resumableObj, $2, offset2, chunkEvent));
                  $2.resumableObj.fire("chunkingProgress", $2, offset2 / maxOffset);
                }, 0);
              })(offset);
            }
            window.setTimeout(function() {
              $2.resumableObj.fire("chunkingComplete", $2);
            }, 0);
          };
          $2.progress = function() {
            if (_error) return 1;
            var ret = 0;
            var error = false;
            $h.each($2.chunks, function(c) {
              if (c.status() == "error") error = true;
              ret += c.progress(true);
            });
            ret = error ? 1 : ret > 0.99999 ? 1 : ret;
            ret = Math.max($2._prevProgress, ret);
            $2._prevProgress = ret;
            return ret;
          };
          $2.isUploading = function() {
            var uploading = false;
            $h.each($2.chunks, function(chunk) {
              if (chunk.status() == "uploading") {
                uploading = true;
                return false;
              }
            });
            return uploading;
          };
          $2.isComplete = function() {
            var outstanding = false;
            $h.each($2.chunks, function(chunk) {
              var status = chunk.status();
              if (status == "pending" || status == "uploading" || chunk.preprocessState === 1) {
                outstanding = true;
                return false;
              }
            });
            return !outstanding;
          };
          $2.pause = function(pause) {
            if (typeof pause === "undefined") {
              $2._pause = $2._pause ? false : true;
            } else {
              $2._pause = pause;
            }
          };
          $2.isPaused = function() {
            return $2._pause;
          };
          $2.resumableObj.fire("chunkingStart", $2);
          $2.bootstrap();
          return this;
        }
        function ResumableChunk(resumableObj, fileObj, offset, callback) {
          var $2 = this;
          $2.opts = {};
          $2.getOpt = resumableObj.getOpt;
          $2.resumableObj = resumableObj;
          $2.fileObj = fileObj;
          $2.fileObjSize = fileObj.size;
          $2.fileObjType = fileObj.file.type;
          $2.offset = offset;
          $2.callback = callback;
          $2.lastProgressCallback = /* @__PURE__ */ new Date();
          $2.tested = false;
          $2.retries = 0;
          $2.pendingRetry = false;
          $2.preprocessState = 0;
          var chunkSize = $2.getOpt("chunkSize");
          $2.loaded = 0;
          $2.startByte = $2.offset * chunkSize;
          $2.endByte = Math.min($2.fileObjSize, ($2.offset + 1) * chunkSize);
          if ($2.fileObjSize - $2.endByte < chunkSize && !$2.getOpt("forceChunkSize")) {
            $2.endByte = $2.fileObjSize;
          }
          $2.xhr = null;
          $2.test = function() {
            $2.xhr = new XMLHttpRequest();
            var testHandler = function(e) {
              $2.tested = true;
              var status = $2.status();
              if (status == "success") {
                $2.callback(status, $2.message());
                $2.resumableObj.uploadNextChunk();
              } else {
                $2.send();
              }
            };
            $2.xhr.addEventListener("load", testHandler, false);
            $2.xhr.addEventListener("error", testHandler, false);
            $2.xhr.addEventListener("timeout", testHandler, false);
            var params = [];
            var parameterNamespace = $2.getOpt("parameterNamespace");
            var customQuery = $2.getOpt("query");
            if (typeof customQuery == "function") customQuery = customQuery($2.fileObj, $2);
            $h.each(customQuery, function(k, v) {
              params.push([encodeURIComponent(parameterNamespace + k), encodeURIComponent(v)].join("="));
            });
            params = params.concat(
              [
                // define key/value pairs for additional parameters
                ["chunkNumberParameterName", $2.offset + 1],
                ["chunkSizeParameterName", $2.getOpt("chunkSize")],
                ["currentChunkSizeParameterName", $2.endByte - $2.startByte],
                ["totalSizeParameterName", $2.fileObjSize],
                ["typeParameterName", $2.fileObjType],
                ["identifierParameterName", $2.fileObj.uniqueIdentifier],
                ["fileNameParameterName", $2.fileObj.fileName],
                ["relativePathParameterName", $2.fileObj.relativePath],
                ["totalChunksParameterName", $2.fileObj.chunks.length]
              ].filter(function(pair) {
                return $2.getOpt(pair[0]);
              }).map(function(pair) {
                return [
                  parameterNamespace + $2.getOpt(pair[0]),
                  encodeURIComponent(pair[1])
                ].join("=");
              })
            );
            $2.xhr.open($2.getOpt("testMethod"), $h.getTarget("test", params));
            $2.xhr.timeout = $2.getOpt("xhrTimeout");
            $2.xhr.withCredentials = $2.getOpt("withCredentials");
            var customHeaders = $2.getOpt("headers");
            if (typeof customHeaders === "function") {
              customHeaders = customHeaders($2.fileObj, $2);
            }
            $h.each(customHeaders, function(k, v) {
              $2.xhr.setRequestHeader(k, v);
            });
            $2.xhr.send(null);
          };
          $2.preprocessFinished = function() {
            $2.preprocessState = 2;
            $2.send();
          };
          $2.send = function() {
            var preprocess = $2.getOpt("preprocess");
            if (typeof preprocess === "function") {
              switch ($2.preprocessState) {
                case 0:
                  $2.preprocessState = 1;
                  preprocess($2);
                  return;
                case 1:
                  return;
                case 2:
                  break;
              }
            }
            if ($2.getOpt("testChunks") && !$2.tested) {
              $2.test();
              return;
            }
            $2.xhr = new XMLHttpRequest();
            $2.xhr.upload.addEventListener("progress", function(e) {
              if (/* @__PURE__ */ new Date() - $2.lastProgressCallback > $2.getOpt("throttleProgressCallbacks") * 1e3) {
                $2.callback("progress");
                $2.lastProgressCallback = /* @__PURE__ */ new Date();
              }
              $2.loaded = e.loaded || 0;
            }, false);
            $2.loaded = 0;
            $2.pendingRetry = false;
            $2.callback("progress");
            var doneHandler = function(e) {
              var status = $2.status();
              if (status == "success" || status == "error") {
                $2.callback(status, $2.message());
                $2.resumableObj.uploadNextChunk();
              } else {
                $2.callback("retry", $2.message());
                $2.abort();
                $2.retries++;
                var retryInterval = $2.getOpt("chunkRetryInterval");
                if (retryInterval !== void 0) {
                  $2.pendingRetry = true;
                  setTimeout($2.send, retryInterval);
                } else {
                  $2.send();
                }
              }
            };
            $2.xhr.addEventListener("load", doneHandler, false);
            $2.xhr.addEventListener("error", doneHandler, false);
            $2.xhr.addEventListener("timeout", doneHandler, false);
            var query = [
              ["chunkNumberParameterName", $2.offset + 1],
              ["chunkSizeParameterName", $2.getOpt("chunkSize")],
              ["currentChunkSizeParameterName", $2.endByte - $2.startByte],
              ["totalSizeParameterName", $2.fileObjSize],
              ["typeParameterName", $2.fileObjType],
              ["identifierParameterName", $2.fileObj.uniqueIdentifier],
              ["fileNameParameterName", $2.fileObj.fileName],
              ["relativePathParameterName", $2.fileObj.relativePath],
              ["totalChunksParameterName", $2.fileObj.chunks.length]
            ].filter(function(pair) {
              return $2.getOpt(pair[0]);
            }).reduce(function(query2, pair) {
              query2[$2.getOpt(pair[0])] = pair[1];
              return query2;
            }, {});
            var customQuery = $2.getOpt("query");
            if (typeof customQuery == "function") customQuery = customQuery($2.fileObj, $2);
            $h.each(customQuery, function(k, v) {
              query[k] = v;
            });
            var func = $2.fileObj.file.slice ? "slice" : $2.fileObj.file.mozSlice ? "mozSlice" : $2.fileObj.file.webkitSlice ? "webkitSlice" : "slice";
            var bytes = $2.fileObj.file[func]($2.startByte, $2.endByte, $2.getOpt("setChunkTypeFromFile") ? $2.fileObj.file.type : "");
            var data = null;
            var params = [];
            var parameterNamespace = $2.getOpt("parameterNamespace");
            if ($2.getOpt("method") === "octet") {
              data = bytes;
              $h.each(query, function(k, v) {
                params.push([encodeURIComponent(parameterNamespace + k), encodeURIComponent(v)].join("="));
              });
            } else {
              data = new FormData();
              $h.each(query, function(k, v) {
                data.append(parameterNamespace + k, v);
                params.push([encodeURIComponent(parameterNamespace + k), encodeURIComponent(v)].join("="));
              });
              if ($2.getOpt("chunkFormat") == "blob") {
                data.append(parameterNamespace + $2.getOpt("fileParameterName"), bytes, $2.fileObj.fileName);
              } else if ($2.getOpt("chunkFormat") == "base64") {
                var fr = new FileReader();
                fr.onload = function(e) {
                  data.append(parameterNamespace + $2.getOpt("fileParameterName"), fr.result);
                  $2.xhr.send(data);
                };
                fr.readAsDataURL(bytes);
              }
            }
            var target = $h.getTarget("upload", params);
            var method = $2.getOpt("uploadMethod");
            $2.xhr.open(method, target);
            if ($2.getOpt("method") === "octet") {
              $2.xhr.setRequestHeader("Content-Type", "application/octet-stream");
            }
            $2.xhr.timeout = $2.getOpt("xhrTimeout");
            $2.xhr.withCredentials = $2.getOpt("withCredentials");
            var customHeaders = $2.getOpt("headers");
            if (typeof customHeaders === "function") {
              customHeaders = customHeaders($2.fileObj, $2);
            }
            $h.each(customHeaders, function(k, v) {
              $2.xhr.setRequestHeader(k, v);
            });
            if ($2.getOpt("chunkFormat") == "blob") {
              $2.xhr.send(data);
            }
          };
          $2.abort = function() {
            if ($2.xhr) $2.xhr.abort();
            $2.xhr = null;
          };
          $2.status = function() {
            if ($2.pendingRetry) {
              return "uploading";
            } else if (!$2.xhr) {
              return "pending";
            } else if ($2.xhr.readyState < 4) {
              return "uploading";
            } else {
              if ($2.xhr.status == 200 || $2.xhr.status == 201) {
                return "success";
              } else if ($h.contains($2.getOpt("permanentErrors"), $2.xhr.status) || $2.retries >= $2.getOpt("maxChunkRetries")) {
                return "error";
              } else {
                $2.abort();
                return "pending";
              }
            }
          };
          $2.message = function() {
            return $2.xhr ? $2.xhr.responseText : "";
          };
          $2.progress = function(relative) {
            if (typeof relative === "undefined") relative = false;
            var factor = relative ? ($2.endByte - $2.startByte) / $2.fileObjSize : 1;
            if ($2.pendingRetry) return 0;
            if (!$2.xhr || !$2.xhr.status) factor *= 0.95;
            var s = $2.status();
            switch (s) {
              case "success":
              case "error":
                return 1 * factor;
              case "pending":
                return 0 * factor;
              default:
                return $2.loaded / ($2.endByte - $2.startByte) * factor;
            }
          };
          return this;
        }
        $.uploadNextChunk = function() {
          var found = false;
          if ($.getOpt("prioritizeFirstAndLastChunk")) {
            $h.each($.files, function(file) {
              if (file.chunks.length && file.chunks[0].status() == "pending" && file.chunks[0].preprocessState === 0) {
                file.chunks[0].send();
                found = true;
                return false;
              }
              if (file.chunks.length > 1 && file.chunks[file.chunks.length - 1].status() == "pending" && file.chunks[file.chunks.length - 1].preprocessState === 0) {
                file.chunks[file.chunks.length - 1].send();
                found = true;
                return false;
              }
            });
            if (found) return true;
          }
          $h.each($.files, function(file) {
            if (file.isPaused() === false) {
              $h.each(file.chunks, function(chunk) {
                if (chunk.status() == "pending" && chunk.preprocessState === 0) {
                  chunk.send();
                  found = true;
                  return false;
                }
              });
            }
            if (found) return false;
          });
          if (found) return true;
          var outstanding = false;
          $h.each($.files, function(file) {
            if (!file.isComplete()) {
              outstanding = true;
              return false;
            }
          });
          if (!outstanding) {
            $.fire("complete");
          }
          return false;
        };
        $.assignBrowse = function(domNodes, isDirectory) {
          if (typeof domNodes.length == "undefined") domNodes = [domNodes];
          $h.each(domNodes, function(domNode) {
            var input;
            if (domNode.tagName === "INPUT" && domNode.type === "file") {
              input = domNode;
            } else {
              input = document.createElement("input");
              input.setAttribute("type", "file");
              input.style.display = "none";
              domNode.addEventListener("click", function() {
                input.style.opacity = 0;
                input.style.display = "block";
                input.focus();
                input.click();
                input.style.display = "none";
              }, false);
              domNode.appendChild(input);
            }
            var maxFiles = $.getOpt("maxFiles");
            if (typeof maxFiles === "undefined" || maxFiles != 1) {
              input.setAttribute("multiple", "multiple");
            } else {
              input.removeAttribute("multiple");
            }
            if (isDirectory) {
              input.setAttribute("webkitdirectory", "webkitdirectory");
            } else {
              input.removeAttribute("webkitdirectory");
            }
            var fileTypes = $.getOpt("fileType");
            if (typeof fileTypes !== "undefined" && fileTypes.length >= 1) {
              input.setAttribute("accept", fileTypes.map(function(e) {
                return "." + e;
              }).join(","));
            } else {
              input.removeAttribute("accept");
            }
            input.addEventListener("change", function(e) {
              appendFilesFromFileList(e.target.files, e);
              var clearInput = $.getOpt("clearInput");
              if (clearInput) {
                e.target.value = "";
              }
            }, false);
          });
        };
        $.assignDrop = function(domNodes) {
          if (typeof domNodes.length == "undefined") domNodes = [domNodes];
          $h.each(domNodes, function(domNode) {
            domNode.addEventListener("dragover", preventDefault, false);
            domNode.addEventListener("dragenter", preventDefault, false);
            domNode.addEventListener("drop", onDrop, false);
          });
        };
        $.unAssignDrop = function(domNodes) {
          if (typeof domNodes.length == "undefined") domNodes = [domNodes];
          $h.each(domNodes, function(domNode) {
            domNode.removeEventListener("dragover", preventDefault);
            domNode.removeEventListener("dragenter", preventDefault);
            domNode.removeEventListener("drop", onDrop);
          });
        };
        $.isUploading = function() {
          var uploading = false;
          $h.each($.files, function(file) {
            if (file.isUploading()) {
              uploading = true;
              return false;
            }
          });
          return uploading;
        };
        $.upload = function() {
          if ($.isUploading()) return;
          $.fire("uploadStart");
          for (var num = 1; num <= $.getOpt("simultaneousUploads"); num++) {
            $.uploadNextChunk();
          }
        };
        $.pause = function() {
          $h.each($.files, function(file) {
            file.abort();
          });
          $.fire("pause");
        };
        $.cancel = function() {
          $.fire("beforeCancel");
          for (var i = $.files.length - 1; i >= 0; i--) {
            $.files[i].cancel();
          }
          $.fire("cancel");
        };
        $.progress = function() {
          var totalDone = 0;
          var totalSize = 0;
          $h.each($.files, function(file) {
            totalDone += file.progress() * file.size;
            totalSize += file.size;
          });
          return totalSize > 0 ? totalDone / totalSize : 0;
        };
        $.addFile = function(file, event) {
          appendFilesFromFileList([file], event);
        };
        $.addFiles = function(files, event) {
          appendFilesFromFileList(files, event);
        };
        $.removeFile = function(file) {
          for (var i = $.files.length - 1; i >= 0; i--) {
            if ($.files[i] === file) {
              $.files.splice(i, 1);
            }
          }
        };
        $.getFromUniqueIdentifier = function(uniqueIdentifier) {
          var ret = false;
          $h.each($.files, function(f) {
            if (f.uniqueIdentifier == uniqueIdentifier) ret = f;
          });
          return ret;
        };
        $.getSize = function() {
          var totalSize = 0;
          $h.each($.files, function(file) {
            totalSize += file.size;
          });
          return totalSize;
        };
        $.handleDropEvent = function(e) {
          onDrop(e);
        };
        $.handleChangeEvent = function(e) {
          appendFilesFromFileList(e.target.files, e);
          e.target.value = "";
        };
        $.updateQuery = function(query) {
          $.opts.query = query;
        };
        return this;
      };
      if (typeof module != "undefined") {
        module.exports = Resumable;
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return Resumable;
        });
      } else {
        window.Resumable = Resumable;
      }
    })();
  }
});
export default require_resumable();
//# sourceMappingURL=resumablejs.js.map
